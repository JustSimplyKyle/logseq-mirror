# 變數
	- 在 Rust 中，所有變數都有 ((672f37e6-7911-4973-ab97-e6f5b6236896)) ，但是你可以不用特別把型別寫出來，編譯器會**自動**幫你推斷。
		- ```rust
		  let x = 42;	
		  ```
	- 也可以將型別手動標記出來。
		- ```rust
		  // i32 代表 32 位整數
		  let x: i32 = 42;
		  ```
	- 在 Rust，在預設情況話，所有變數都是 **不可變** 的，需利用 `let mut` 來宣告
		- ```rust
		  let x = 32;
		  x = 87; // 錯誤
		  let mut y = 32;
		  y = 72; // ok
		  ```
	- Rust 同時也支援 **Variables Shadowing**
		- ```rust
		  let x = 32;
		  let x = 64;
		  // x == 64
		  ```
- # 型別
  id:: 672f37e6-7911-4973-ab97-e6f5b6236896
	- ## 數值
		- `i8` `i16` `i32` `i64`
			- 分別代表 `8`,`16`,`32` 及 `64` 位的**有**符號整數
		- `u8` `u16` `u32` `u64`
			- 分別代表 `8`,`16`,`32` 及 `64` 位的**無**符號整數
		- `f32` `f64`
			- 分別代表 `32` 及 `64` 位精度的浮點數
			- [[浮點數的陷阱]]
		- ### 運算
			- `+` `-` `*` `/` `%`
				- 分別代表 **加**、**減**、**乘**、**除** 及**取模** 等運算
			- 要注意的是，只有 **完全相同** 的類型才能運算，因此下列程式碼不會通過編譯
				- ```rust
				  let x: i32 = 20;
				  let y: i64 = 30;
				  let z = x + y; // ERROR
				  ```
- # 函數
	- 看懂下面這張圖你就會了。
	- ![image.png](../assets/image_1731148907978_0.png)
	- 簡單來說，與其他語言的差異：
		- 返回型別**後製**
		- 以 `fn` 表函數開頭
	- #+BEGIN_NOTE
	  由於 Rust 是 **強型別語言**，所有函數都需具有返回型別
	  #+END_NOTE
- # 表達式 vs 語句
	- ## 再談函數
		- 所有函數都需具有返回型別，那請問 main 函數的返回型別為何？
			- ```rust
			  fn main() -> ???? {
			    
			  }
			  ```
		- 當我們發現一個函數沒有要傳回一個值的時候，我們用 `()`**元組**型別來代表
			- ```rust
			  fn main() -> () {
			    	
			  }
			  ```
		- 而當我們省略返回型別時，**元組**型別即為預設型別。
	- ## 何謂表達式
		- 一種會 **返回** 值的操作：
			- `3+5`
			- `x+y`
			- `func()`
		- 因此，**函數**即為一種表達式
	- ## 何謂語句
		- 當我們在加了一個 **分號**，任何的表達式都會變成語句。
		- ```rust
		  fn main() {
		    	let x = {
		      	  
		    	};
		  }
		  ```